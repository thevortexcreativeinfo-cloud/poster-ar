/* ---------- CORAZONES: tap para crear, drag + física (robusto) ---------- */
const hearts=[]; // {el,x,y,vx,vy}
const area = { x1:-0.5+0.03, x2:0.5-0.03, y1:-H/2+0.03, y2:H/2-0.03 };

const dragPlane=document.createElement('a-plane');
dragPlane.classList.add('dragplane');
dragPlane.setAttribute('width',1);
dragPlane.setAttribute('height',H);
dragPlane.setAttribute('position','0 0 0.06'); // por delante del vídeo (0.02) y overlay (0.00)
dragPlane.setAttribute('material','transparent:true; opacity:0; side:double; depthTest:false; depthWrite:false');
root.appendChild(dragPlane);
setRO(dragPlane, 130, false, false);
refreshRay();

/* helpers de raycast súper fiables */
function pointerOn(el){
  const ray = getRay();
  if(!ray) return null;
  const hit = ray.getIntersection(el);   // << preferible a leer ray.intersections
  if(!hit || !hit.point) return null;
  const p = hit.point.clone ? hit.point.clone() : new AFRAME.THREE.Vector3(hit.point.x,hit.point.y,hit.point.z);
  root.object3D.worldToLocal(p);
  return {x:clamp(p.x,area.x1,area.x2), y:clamp(p.y,area.y1,area.y2), dist:hit.distance};
}
function pointerLocal(){ return pointerOn(dragPlane); }

/* spawn de corazones (siempre delante del dragPlane) */
function spawnHeart(x,y){
  const h = document.createElement('a-image');
  h.classList.add('heart');
  h.setAttribute('src', '#heartImg');
  h.setAttribute('width', 0.14);
  h.setAttribute('height', 0.14);
  h.setAttribute('position', `${x} ${y} 0.08`);
  h.setAttribute('material', 'transparent:true; alphaTest:0.01; side:double; depthTest:false; depthWrite:false');
  root.appendChild(h);
  setRO(h, 140, false, false);
  hearts.push({el:h, x, y, vx:(Math.random()-0.5)*0.3, vy:(Math.random()-0.5)*0.3});
  if(hearts.length>28){ const old=hearts.shift(); old?.el?.remove(); }
  refreshRay();
}

/* tap para crear corazón (usamos pointerdown + click por compatibilidad) */
function handleTap(){
  const p = pointerLocal();
  if(!p) return;
  spawnHeart(p.x,p.y);
}
dragPlane.addEventListener('pointerdown', e=>{ e.stopPropagation(); handleTap(); });
dragPlane.addEventListener('click',       e=>{ e.stopPropagation(); handleTap(); });

/* selección del corazón bajo el puntero (elige el más cercano) */
function pickHeart(){
  const ray = getRay();
  if(!ray) return null;
  let best=null, bestDist=Infinity;
  for(const h of hearts){
    const hit = ray.getIntersection(h.el);
    if(hit && hit.distance<bestDist){ best=h; bestDist=hit.distance; }
  }
  return best;
}

/* arrastre + física */
let dragging=null, dragOffset={x:0,y:0}, lastPointer=null, lastTime=0;

scene.addEventListener('pointerdown', ()=>{
  const h = pickHeart();
  if(!h) return;
  const p = pointerLocal(); if(!p) return;
  dragging=h; dragOffset={x:h.x-p.x, y:h.y-p.y}; lastPointer=p; lastTime=performance.now();
});
scene.addEventListener('pointerup',   ()=>{ dragging=null; });
scene.addEventListener('pointerleave',()=>{ dragging=null; });

(function heartsTick(){
  const dt=1/60, g=-0.4, damp=0.60;
  const now=performance.now();
  const p=pointerLocal();

  if(dragging && p){
    const nx=clamp(p.x+dragOffset.x, area.x1, area.x2);
    const ny=clamp(p.y+dragOffset.y, area.y1, area.y2);
    if(lastPointer){
      const dtms=Math.max(16, now-lastTime);
      dragging.vx=(nx-dragging.x)/(dtms/1000);
      dragging.vy=(ny-dragging.y)/(dtms/1000);
    }
    dragging.x=nx; dragging.y=ny;
    lastPointer=p; lastTime=now;
  }

  for(const o of hearts){
    if(o!==dragging){ o.vy+=g*dt; o.x+=o.vx*dt; o.y+=o.vy*dt; }
    if(o.x<area.x1){ o.x=area.x1; o.vx*=-damp; }
    if(o.x>area.x2){ o.x=area.x2; o.vx*=-damp; }
    if(o.y<area.y1){ o.y=area.y1; o.vy*=-damp; }
    if(o.y>area.y2){ o.y=area.y2; o.vy*=-damp; }
    o.el.setAttribute('position', `${o.x} ${o.y} 0.08`);
    o.el.setAttribute('rotation', `0 0 ${Math.sin(performance.now()/300 + o.x*10)*6}`);
  }

  requestAnimationFrame(heartsTick);
})();
